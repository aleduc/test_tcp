## Алгоритм
http://hashcash.org/
* Нашел что он используется для подобных целей.
* SHA1 устарел, SHA-256 хватит.
* Легко корректируется сложность, что позволит при нормальной архитектуре динамически менять сложность.

## Принципы написания кода
1. Плоская структура с одним пакетом и вложенным пакетом.
2. Из пункта 1 следуют проблемы с именованием(имена далека не идеальны), но для небольшого тестового вполне.
3. SOLID нарушен, хотя бы потому что толком нет разделения на пакеты(пункт 1)
4. KISS
5. Местами использовал упрощения.
6. Все интерфейсы и структуры глобальные. 
7. Не которые вещи(время к примеру) не интерфейсы и т д. Т.к. код не оптимизирован для юнит-тестов.

## Описание(по файлам/структурам)
По файлам, т.к. не все структуры имеют интерфейсы и не все получится описать тогда. 
1. Server - отвечает за прием коннектов и старт сервера.
 * Listen - начинает слушать
 * Serve - входящие коннекты отправляет в канал, который обрабатывают воркеры, так же имет грейсфул стоп. 
 * Close - единое закрытие.  Закрывает прослушку по порту, потом ждет пока воркеры доработают имеющие коннекты.
Затем закрывает канал коннектов, что автоматически останавливает воркеров.
2. Pool - стартует воркеров.
3. Worker - в цикле for работает с каналом коннектов и вызывает для них handle/
4. Handler - читает данные из коннекта, проводит валидацию с помощью Validator и пишет wisdom в коннект в случае успеха.
5. Wisdom - имитация базы с мудростями.
6. logger - логирует со стэктрейсом, использовал свой. Единственный кто импортирует внешние зависимости.
7. randomizer - рандом для асинхронной работы, используется в Wisdom
8. validate/validator - работает со слайсом валидаторов, вызывает их все и в случае ошибки выходит.
9. validate/expire - отвечает за проверку, не наступил ли деадлайн для пришедшего времени генерации.
10. validate/hash 
 * проверяет что в хэше нужное кол-во нулей
 * на основе пришедших данных проверяет что этот хэш сгенерирован правильно
 * проверяет что пришедший хэш соответствует сгенерированному

## Комментарии
1. Я использовал канал net.conn вместо структуры Job с параметрами и т д для упрощения и за ненадобностью(этот проект не будет дальше рзвиваться и параметры не изменяться).
2. В идеале мэйн не должен иметь столько инициализаций, это можно вынести. 
3. Сервер, принимает канал на отправку заданий, канал имеет какой-то буффер.
Выполняет роль продюсера
4. Есть пуллер, который стартует воркеров, выолняют роль консьюмера.
5. Вместо email я использую ip адрес, т.е. подразумевается что клиент знает с каким адресом он придет.
Это подразумевает что между клиентом и сервером нету прокси и балансировщиков. 
Для теста: Клиент и сервер в одной сетке.
Для прода: зависит что за клиент, что за сервер и откуда приходят, можно это либо убрать, либо заменить.
С базой проверки повторений, маленьким временем жизни, нам хватит и clientID.
6. Собственно про базу повторений. Можно добавить кэшик, чтобы нельзя было спамить одним и тем же хэшом в рамках lifetime.
## Формат сообщения
1. Первые 8 байт, unixtimestamp
2. Следующие 12 байт это рандомные байты.
3. Следующие 12 это счетчик
4. Следующие 32 сам хэш

## Build
1. Сначала запускаем сервер
2. docker network create \
   --driver=bridge \
   --subnet=172.28.0.0/16 \
   --ip-range=172.28.5.0/24 \
   --gateway=172.28.5.254 \
   test_isolated
3. docker build -t tcp_server . 
4. docker run --net=test_isolated --ip 172.28.5.3 --name tcp_server tcp_server

